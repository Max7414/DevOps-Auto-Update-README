name: Update README Activity

on:
  workflow_dispatch:    # 手動觸發
  push:                 # 推到 main 觸發
    branches: [ main ]
  pull_request:         # PR 關閉時觸發；僅 merged 才會繼續執行
    types: [ closed ]

permissions:
  contents: write       # 需寫回 README.md
  pull-requests: read   # 讀 PR 狀態
  # issues/metadata 會由 GitHub 預設 read 權限處理；若組織策略嚴格可顯式加上：
  # issues: read
  # metadata: read

concurrency:
  group: update-readme
  cancel-in-progress: false

jobs:
  build:
    # 只有在 PR 事件且 merged==true 時才跑；其他事件（push/手動）照常跑
    if: github.event_name != 'pull_request' || github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false  # 避免使用 GITHUB_TOKEN 推送，改用 PAT（REPO_TOKEN）

      - name: Generate activity markdown
        id: gen
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const { owner, repo } = context.repo;

            // 最近 5 個 merged PR
            const prs = await github.paginate(
              github.rest.pulls.list,
              { owner, repo, state: 'closed', per_page: 50 }
            );
            const merged = prs.filter(p => p.merged_at).slice(0, 5);

            // 最近 5 個 commits（預設分支）
            const commits = await github.paginate(
              github.rest.repos.listCommits,
              { owner, repo, per_page: 10 }
            );
            const latestCommits = commits.slice(0, 5);

            const fmtDate = (s) => new Date(s).toISOString().slice(0,10);

            let lines = [];

            if (merged.length) {
              lines.push("### Merged PRs");
              for (const p of merged) {
                lines.push(`- #${p.number} **${p.title}** by @${p.user.login} — merged ${fmtDate(p.merged_at)}`);
              }
              lines.push("");
            }

            if (latestCommits.length) {
              lines.push("### Latest Commits");
              for (const c of latestCommits) {
                const sha = c.sha.slice(0,7);
                const msg = (c.commit.message || "").split("\n")[0];
                const when = c.commit.author?.date ? fmtDate(c.commit.author.date) : "";
                lines.push(`- \`${sha}\` ${msg} — ${when}`);
              }
              lines.push("");
            }

            return lines.length ? lines.join("\n") : "_No recent activity_";

      - name: Replace README section (safe heredoc)
        run: |
          node <<'NODE'
          const fs = require('fs');
          const p = 'README.md';
          const start = '<!--START_SECTION:activity-->';
          const end = '<!--END_SECTION:activity-->';
          const md = process.env.MARKDOWN || '';
          let s = fs.readFileSync(p, 'utf8');

          // 使用模板字串 + 安全的字面量邊界
          const re = new RegExp(`${start}[\\s\\S]*?${end}`, 'm');

          if (!re.test(s)) {
            console.error('Markers not found in README.md');
            process.exit(2); // 當作品質把關：沒有標記就失敗
          }

          const block = `${start}\n${md}\n${end}`;
          const out = s.replace(re, block);

          if (out !== s) {
            fs.writeFileSync(p, out);
            console.log('README updated.');
          } else {
            console.log('No changes needed.');
          }
          NODE
        env:
          MARKDOWN: ${{ steps.gen.outputs.result }}

      - name: Commit & push (using least-priv PAT)
        run: |
          set -e

          # 若沒有檔案變更，直接結束
          if git diff --quiet; then
            echo "No change to commit."
            exit 0
          fi

          git config user.name "readme-bot"
          git config user.email "readme-bot@users.noreply.github.com"
          git add README.md
          git commit -m "chore(readme): auto-update [skip ci]"

          # 以 PAT 推送，避免在 log 顯示 token
          git remote set-url origin https://x-access-token:${REPO_TOKEN}@github.com/${GITHUB_REPOSITORY}.git
          git push origin HEAD:main
        env:
          REPO_TOKEN: ${{ secrets.REPO_TOKEN }}
